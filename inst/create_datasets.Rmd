# Working with the `pbmc3k` dataset

## Preparation of example scRNAseq data

```{r libbioc}
library("BiocStyle")
```


In this workshop, we use example data from the `r Biocpkg("TENxPBMCData")` package.
This package provides an _R / Bioconductor_ resource for representing and manipulating different single-cell RNA-seq data sets profiling peripheral blood mononuclear cells (PBMC) generated by 10x Genomics (https://support.10xgenomics.com/single-cell-gene-expression/datasets).

```{r loadtenx, message=FALSE}
library("TENxPBMCData")
```

The man page for the `TENxPBMCData()` function gives an idea of the datasets that are available from this package.
It can be opened with the following command.

```{r helptenx, eval=FALSE}
help(TENxPBMCData)
```

Here, we use the `pbmc3k` dataset, which contains gene expression profiles for 2,700 single peripheral blood mononuclear cells.
The first time this dataset is loaded, this command downloads the dataset to a local cache, which takes some time, depending on the speed of your internet connection.
Subsequent times, the same command loads the dataset directly from the local cache.

```{r loadsce, message=FALSE, warning=FALSE}
sce <- TENxPBMCData(dataset = "pbmc3k")
```

At this point we can inspect the dataset in the console.

```{r printsce}
sce
```

```{r}
counts(sce) <- as(counts(sce), "dgCMatrix")
```


The dataset is provided as an object of the `SingleCellExperiment` class.
In particular, this summary view indicates that the following pieces of information are available:

- An assay matrix named `counts`
- Row (i.e., gene) names are Ensembl gene IDs
- Row metadata include for each gene the official gene symbol, and the gene symbol used by the
10x CellRanger quantification pipeline
- Column (i.e., cell) IDs are not initialized and left to `NULL`
- Column metadata include diverse information for each cell, including the cell barcode (`Barcode`) and the donor identifier (`Individual`).

Note that a `SingleCellExperiment` object (or, more generally, any `SummarizedExperiment` object) like this one already contains sufficient information to launch an interactive application instance to visualize the available data and metadata, using the `iSEE()` function.

For the purpose of this workshop, we first apply some preprocessing to the `SingleCellExperiment` object, in order to populate it with more information that can be visualized with `iSEE`.

We start by adding column names to the object, and use gene symbols instead of Ensembl IDs as row names.
In the case where multiple Ensembl identifiers correspond to the same gene symbol, the `scater::uniquifyFeatureNames` function concatenates the Ensembl ID and the gene symbol in order to generate unique feature names.

```{r rownamesrename, message=FALSE}
library("scater")
colnames(sce) <- paste0("Cell", seq_len(ncol(sce)))
rownames(sce) <- scater::uniquifyFeatureNames(
  ID = rowData(sce)$ENSEMBL_ID,
  names = rowData(sce)$Symbol_TENx
)
head(rownames(sce))
```

Next, we use the `r Biocpkg("scater")` package to calculate gene- and cell-level quality metrics.
These metrics are added as columns to the `rowData` and `colData` slots of the `SingleCellExperiment` object, respectively.
We also add some additional metrics that are not automatically computed by the `r Biocpkg("scater")` package.

```{r mitos, message = FALSE}
MT <- rownames(sce)[grep("^MT-", rownames(sce))]
sce <- scater::addPerCellQC(sce, subsets = list(MT = MT))
sce <- scater::addPerFeatureQC(sce)
sce$log10_total <- log10(sce$total)
rowData(sce)$n_cells <- as.integer(rowData(sce)$detected * ncol(sce))
rowData(sce)$log10_total <- log10(rowSums(assay(sce, "counts")) + 1)
sce
```

We filter out a few cells with a large fraction of the counts coming from mitochondrial genes, since these may be damaged cells.
Notice the reduced number of columns in the dataset below.

```{r mitofilter}
(sce <- sce[, sce$subsets_MT_percent < 5])
```

Next, we calculate size factors and normalized and log-transformed expression values, using the `r Biocpkg("scran")` and `r Biocpkg("scater")` packages.
Note that it is typically recommended to pre-cluster the cells before computing the size factors, as follows:


<!-- ```{r} -->
<!-- # set.seed(1000) -->
<!-- # clusters <- scran::quickCluster(sce, BSPARAM = IrlbaParam()) -->
<!-- # sce <- scran::computeSumFactors(sce, cluster = clusters, min.mean = 0.1) -->
<!-- ``` -->


<!-- However, for time reasons, we will skip the pre-clustering step in this workshop. -->

```{r normalize, message=FALSE}
library("scran")
set.seed(1000)
sce <- scran::computeSumFactors(sce, min.mean = 0.1)
summary(sizeFactors(sce))
sce <- scater::logNormCounts(sce)
```

In order to extract the most informative genes, we first model the mean-variance trend and decompose the variance into biological and technical components.

```{r mgv}
dec <- scran::modelGeneVar(sce)
top.dec <- dec[order(dec$bio, decreasing = TRUE), ]
head(top.dec)
```

Next, we apply Principal Components Analysis (PCA) and t-distributed Stochastic Neighbor Embedding (t-SNE) to generate low-dimensional representations of the cells in our data set.
These low-dimensional representations are added to the `reducedDim` slot of the `SingleCellExperiment` object.

```{r reddims, message=FALSE}
library("BiocSingular")
set.seed(1000)
sce <- scran::denoisePCA(sce, technical = dec)
ncol(reducedDim(sce, "PCA"))
set.seed(1000)
sce <- scater::runTSNE(sce, dimred = "PCA", perplexity = 30)
sce <- scater::runUMAP(sce, dimred = "PCA")
sce
```

Finally, we cluster the cells using a graph-based algorithm, and find 'marker genes' for each cluster as the genes that are significantly upregulated in the cluster compared to each of the other inferred clusters.
The adjusted p-values from this test, for each cluster, are added to the `rowData` slot of the object.

```{r clusters}
snn.gr <- scran::buildSNNGraph(sce, use.dimred = "PCA")
clusters <- igraph::cluster_walktrap(snn.gr)
sce$Cluster <- factor(clusters$membership)
table(sce$Cluster)

markers <- scran::findMarkers(sce,
  groups = sce$Cluster,
  test.type = "t",
  direction = "up", pval.type = "all"
)
for (i in names(markers)) {
  rowData(sce)[, paste0("FDR_cluster", i)] <-
    markers[[i]]$FDR[match(
      rownames(sce),
      rownames(markers[[i]])
    )]
}
sce
```


Finally, we assign a label to each cell, based on their individual transcriptome profiles, using the `SingleR` method and the Monaco immune data (https://doi.org/10.1016/j.celrep.2019.01.041) as a reference.  
For each prediction, we assign the labels values to a specific `colData` element

```{r loadsingler, message=FALSE}
library("SingleR")
library("celldex")
ref_monaco <- MonacoImmuneData()
```

Here we assign the cell type according to the main classification scheme 
(this includes `r knitr::combine_words(names(table(ref_monaco$label.main)))`)

```{r annomain}
pred_monaco_main <- SingleR(
  test = sce,
  ref = ref_monaco,
  labels = ref_monaco$label.main
)
table(pred_monaco_main$labels)
sce$labels_main <- pred_monaco_main$labels
```

We do something similar with a more fine-grained classification, this time including the cell subtypes (e.g., for `r sort(unique(ref_monaco$label.main))[1]`, the subtypes would include `r knitr::combine_words(names(table((ref_monaco$label.main), (ref_monaco$label.fine))[1, ])[which(table((ref_monaco$label.main), (ref_monaco$label.fine))[1,] > 0)])`)

```{r annofine}
pred_monaco_fine <- SingleR(
  test = sce,
  ref = ref_monaco,
  labels = ref_monaco$label.fine
)
table(pred_monaco_fine$labels)
sce$labels_fine <- pred_monaco_fine$labels
```

Similarly, we use the information contained in the cell ontology labels.

```{r annocl}
pred_monaco_ont <- SingleR(
  test = sce,
  ref = ref_monaco,
  labels = ref_monaco$label.ont
)
table(pred_monaco_ont$labels)
sce$labels_ont <- pred_monaco_ont$labels
```

We can add that info in a more readable way with this set of commands

```{r infocellonto}
library("ontoProc")
cl <- getOnto("cellOnto")
cl

translated <- cl$name[ref_monaco$label.ont]
head(translated)

sce$cell_ontology_labels <- cl$name[pred_monaco_ont$labels]
```


The next table shows the relationship between the coarse and fine grained assignments in the data at hand.

```{r compareanno}
table(
  sce$labels_main,
  sce$labels_fine
)

table(
  sce$labels_main,
  sce$cell_ontology_labels
)
```


This concludes the preparation of the data.
We have now a `SingleCellExperiment` object that contains different types of abundance values, representations in reduced dimensions, as well as a range of row (feature) and column (cell) metadata.

We can launch an `r Biocpkg("iSEE")` instance for exploring this data set using the `iSEE()` function:

```{r launchisee, message=FALSE}
library("iSEE")

if (interactive()) {
  iSEE(sce)
}
```

```{r saveobj}
saveRDS(sce,
  file = "datasets/sce_pbmc3k.RDS"
)

sce_pbmc3k <- readRDS("datasets/sce_pbmc3k.RDS")
```


## Interoperability

### What about the same dataset, but for Seurat?

```{r convertseurat, eval=FALSE}
library("Seurat")
# seurat_object <- as.Seurat(sce)

seurat_object <- Seurat::CreateSeuratObject(
  counts = as.matrix(counts(sce)),
  meta.data = as.data.frame(colData(sce))
)

seurat_object <- Seurat::SetAssayData(
  object = seurat_object,
  slot = "data",
  new.data = as.matrix(logcounts(sce))
)

# Set feature metadata, AKA rowData. Super intuitive, right?
seurat_object[["RNA"]][[]] <- as.data.frame(rowData(sce))

seurat_object <- FindVariableFeatures(seurat_object, selection.method = "vst", nfeatures = 2000)

all.genes <- rownames(seurat_object)
seurat_object <- ScaleData(seurat_object, features = all.genes)

seurat_object <- RunPCA(seurat_object, features = VariableFeatures(seurat_object))
seurat_object <- RunUMAP(seurat_object, dims = 1:10)

saveRDS(seurat_object,
  file = "datasets/seurat_pbmc3k.RDS"
)

sce_from_seurat <- Seurat::as.SingleCellExperiment(
  readRDS("datasets/seurat_pbmc3k.RDS")
)
sce_from_seurat

if (interactive()) {
  iSEE(sce_from_seurat)
}
```

### And where is my AnnData object?

```{r convertanndata}
library("zellkonverter")

sce$Tissue_status <- NULL

zellkonverter::writeH5AD(sce,
  file = "datasets/anndata_pbmc3k.h5ad",
  compression = "gzip"
)

sce_from_anndata <- zellkonverter::readH5AD(file = "datasets/anndata_pbmc3k.h5ad")
sce_from_anndata

if (interactive()) {
  iSEE(sce_from_anndata)
}
```


# Another single-cell dataset, from Bartneck et al.

To obtain a preprocessed version of this dataset, navigate to

https://seafile.rlp.net/d/c7f1335a6248427d97da/

then navigate to the `sce_objects` folder, and from there select the `sce_merged_allsets.RDS` file, and download it locally.


# `iSEE` bulk data! Loading and processing the `macrophage` data set

The data set that will be used for this demo is a bulk RNA-seq data set containing 24 samples from Alasoo, et al: "Shared genetic effects on chromatin and gene expression indicate a role for enhancer priming in immune response", published in Nature Genetics, January 2018. 
The 24 samples correspond to 6 different donors. 
For each of these we have four samples: one naive, one exposed to IFNgamma, one exposed to Salmonella, and one exposed to IFNgamma and Salmonella. 
The `r Biocpkg("macrophage")` Bioconductor package provides the output files resulting from running Salmon on these 24 samples. 
Here, we load the quantifications into R using the `r Biocpkg("tximeta")` package.

```{r macrophagerun}
library("macrophage")
library("DESeq2")
library("limma")
library("edgeR")
library("tximeta")
library("org.Hs.eg.db")
library("fgsea")
library("GO.db")
library("stringr")
library("SingleCellExperiment")

library("iSEEde")
library("iSEEpathways")

## Set the data directory
dir <- system.file("extdata", package = "macrophage")

## Read sample annotations
coldata <- read.csv(file.path(dir, "coldata.csv"))[, c(1, 2, 3, 5)]

## Create new columns indicating, respectively whether the sample was exposed
## to IFNgamma and Salmonella
coldata$IFNg <- as.character(grepl("IFNg", coldata$condition_name))
coldata$SL1344 <- as.character(grepl("SL1344", coldata$condition_name))

## Add paths to quantification files and import data
coldata$files <- file.path(dir, "quants", coldata$names, "quant.sf.gz")
se <- tximeta(coldata = coldata, type = "salmon", dropInfReps = TRUE)

## Summarize to the gene level and add additional identifiers
seg <- summarizeToGene(se)
rownames(seg) <- str_replace(rownames(seg), "\\.\\d+$", "")
seg <- addIds(seg, "SYMBOL")
seg <- addIds(seg, "GOALL", multiVals = "list")
rownames(seg) <- scater::uniquifyFeatureNames(
  ID = rownames(seg), names = rowData(seg)$SYMBOL
)

## Create a DESeqDataSet and filter lowly expressed genes
dds <- DESeqDataSet(seg, design = ~ IFNg * SL1344)
keep <- rowSums(counts(dds)) >= 10
dds <- dds[keep, ]

dds

## Apply a variance stabilizing transform followed by PCA
vst <- DESeq2::varianceStabilizingTransformation(dds, blind = TRUE)
pca <- DESeq2::plotPCA(vst, intgroup = "condition_name", returnData = TRUE)

## Create a SingleCellExperiment object and include the PCA representation
sce_macrophage <- as(dds, "SingleCellExperiment")
assay(sce_macrophage, "vst") <- assay(vst)
SingleCellExperiment::reducedDim(sce_macrophage, "PCA") <- pca[, c("PC1", "PC2")]

sce_macrophage
```

## Performing differential expression analysis

Below, we will illustrate how to use the `r Biocpkg("iSEEde")` and `r Biocpkg("iSEEpathways")` packages to visualize results from differential expression analyses.
Thus, we first apply the `r Biocpkg("DESeq2")` and `r Biocpkg("limma")` packages to perform differential expression analysis.
We test the interaction effect between IFNgamma and Salmonella exposure, to investigate whether the effect of Salmonella exposure is different depending on whether or not the sample was also exposed to IFNgamma.

```{r runlimma}
## Run DESeq2
dds <- DESeq2::DESeq(dds)
DESeq2::resultsNames(dds)
res <- DESeq2::results(dds,
  name = "IFNgTRUE.SL1344TRUE",
  lfcThreshold = 0
)

## Embed the contrast results obtained from DESeq2 into the SCE
stopifnot(rownames(res) == rownames(sce_macrophage))
sce_macrophage <- embedContrastResults(res,
  sce_macrophage,
  name = "IFNgTRUE.SL1344TRUE.DESeq2"
)

sce_macrophage

## Run limma-trend
dge <- tximeta::makeDGEList(seg)
dge <- dge[rownames(dds), ]
logCPM <- edgeR::cpm(dge, log = TRUE, prior.count = 3)
design <- model.matrix(~ IFNg * SL1344, data = dge$samples)
fit <- limma::lmFit(logCPM, design = design)
fit <- eBayes(fit, trend = TRUE)
tt <- topTable(fit, coef = ncol(design), number = Inf, sort.by = "none")

## Embed the results obtained from limma into the SCE
stopifnot(rownames(tt) == rownames(sce_macrophage))
sce_macrophage <- embedContrastResults(tt,
  sce_macrophage,
  name = "IFNgTRUE.SL1344TRUE.limma",
  class = "limma"
)

sce_macrophage

## Where's the information stored?
rowData(sce_macrophage)$iSEEde
```

## Perform pathway analysis

We also run `r Biocpkg("fgsea")` to perform a gene set enrichment analysis of GO terms, based on the `DESeq2` results obtained above.

```{r runfgsea}
## Extract GO term composition
pathways <- select(org.Hs.eg.db, keys(org.Hs.eg.db, "SYMBOL"), c("GOALL"),
  keytype = "SYMBOL"
)
pathways <- subset(pathways, ONTOLOGYALL == "BP")
pathways <- unique(pathways[, c("SYMBOL", "GOALL")])
pathways <- split(pathways$SYMBOL, pathways$GOALL)
len_pathways <- lengths(pathways)
pathways <- pathways[len_pathways > 15 & len_pathways < 200]
length(pathways)

## Get test statistics and apply fgsea
feature_stats <- res$stat
names(feature_stats) <- rownames(res)
set.seed(42)
fgseaRes <- fgsea(
  pathways = pathways,
  stats = feature_stats,
  minSize = 15,
  maxSize = 200
)
fgseaRes <- fgseaRes[order(pval), ]

head(fgseaRes)

## Embed pathway analysis results in the SCE object
sce_macrophage <- embedPathwaysResults(fgseaRes,
  sce_macrophage,
  name = "IFNgTRUE.SL1344TRUE.DESeq2.fgsea",
  class = "fgsea",
  pathwayType = "GO",
  pathwaysList = pathways,
  featuresStats = feature_stats
)

sce_macrophage
## Again: where's the data stored?
metadata(sce_macrophage)$iSEEpathways

## Add details about the GO terms
## These will be displayed in the application
go_details <- function(x) {
  info <- select(GO.db, x, c("TERM", "ONTOLOGY", "DEFINITION"), "GOID")
  html <- list(p(strong(info$GOID), ":", info$TERM, paste0("(", info$ONTOLOGY, ")")))
  if (!is.na(info$DEFINITION)) {
    html <- append(html, list(p(info$DEFINITION)))
  }
  tagList(html)
}

## Define the mapping from GO terms to gene IDs
map_GO <- function(pathway_id, se) {
  pathway_symbol <- mapIds(org.Hs.eg.db, pathway_id, "SYMBOL",
    keytype = "GOALL", multiVals = "CharacterList"
  )[[pathway_id]]
  pathway_rownames <- rownames(se)[rowData(se)$SYMBOL %in% pathway_symbol]
  pathway_rownames
}

## Register the pathway mapping information into the SCE object
sce_macrophage <- registerAppOptions(sce_macrophage, Pathways.map.functions = list(GO = map_GO))
sce_macrophage <- registerAppOptions(sce_macrophage, PathwaysTable.select.details = go_details)

metadata(sce_macrophage)$iSEE
```

This concludes the preparation of the dataset for this workshop.  
We can conveniently store that as a binary RDS file which we can load afterwards, anytime.

```{r savemac}
saveRDS(sce_macrophage, "datasets/sce_macrophage_readytouse.RDS")
```


# Session info {-}

```{r sessioninfo}
sessionInfo()
```

