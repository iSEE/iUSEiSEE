# Preparation of example scRNAseq data

```{r}
library("BiocStyle")
```


In this workshop, we use example data from the `r Biocpkg("TENxPBMCData")` package.
This package provides an _R / Bioconductor_ resource for representing and manipulating different single-cell RNA-seq data sets profiling peripheral blood mononuclear cells (PBMC) generated by 10x Genomics (https://support.10xgenomics.com/single-cell-gene-expression/datasets).

```{r, message=FALSE}
library("TENxPBMCData")
```

The man page for the `TENxPBMCData()` function gives an idea of the datasets that are available from this package.
It can be opened with the following command.

```{r, eval=FALSE}
help(TENxPBMCData)
```

Here, we use the `pbmc3k` dataset, which contains gene expression profiles for 2,700 single peripheral blood mononuclear cells.
The first time this dataset is loaded, this command downloads the dataset to a local cache, which takes some time, depending on the speed of your internet connection.
Subsequent times, the same command loads the dataset directly from the local cache.

```{r, message=FALSE, warning=FALSE}
sce <- TENxPBMCData(dataset = "pbmc3k")
```

At this point we can inspect the dataset in the console.

```{r}
sce
```

The dataset is provided as an object of the `SingleCellExperiment` class.
In particular, this summary view indicates that the following pieces of information are available:

- An assay matrix named `counts`
- Row (i.e., gene) names are Ensembl gene IDs
- Row metadata include for each gene the official gene symbol, and the gene symbol used by the
10x CellRanger quantification pipeline
- Column (i.e., cell) IDs are not initialized and left to `NULL`
- Column metadata include diverse information for each cell, including the cell barcode (`Barcode`) and the donor identifier (`Individual`).

Note that a `SingleCellExperiment` object (or, more generally, any `SummarizedExperiment` object) like this one already contains sufficient information to launch an interactive application instance to visualize the available data and metadata, using the `iSEE()` function.

For the purpose of this workshop, we first apply some preprocessing to the `SingleCellExperiment` object, in order to populate it with more information that can be visualized with `iSEE`.

We start by adding column names to the object, and use gene symbols instead of Ensembl IDs as row names.
In the case where multiple Ensembl identifiers correspond to the same gene symbol, the `scater::uniquifyFeatureNames` function concatenates the Ensembl ID and the gene symbol in order to generate unique feature names.

```{r, message=FALSE}
library("scater")
colnames(sce) <- paste0("Cell", seq_len(ncol(sce)))
rownames(sce) <- scater::uniquifyFeatureNames(
    ID = rowData(sce)$ENSEMBL_ID,
    names = rowData(sce)$Symbol_TENx
)
head(rownames(sce))
```

Next, we use the `r Biocpkg("scater")` package to calculate gene- and cell-level quality metrics.
These metrics are added as columns to the `rowData` and `colData` slots of the `SingleCellExperiment` object, respectively.
We also add some additional metrics that are not automatically computed by the `r Biocpkg("scater")` package.

```{r, message = FALSE}
MT <- rownames(sce)[grep("^MT-", rownames(sce))]
sce <- scater::addPerCellQC(sce, subsets = list(MT = MT))
sce <- scater::addPerFeatureQC(sce)
sce$log10_total <- log10(sce$total)
rowData(sce)$n_cells <- as.integer(rowData(sce)$detected * ncol(sce))
rowData(sce)$log10_total <- log10(rowSums(assay(sce, "counts")) + 1)
sce
```

We filter out a few cells with a large fraction of the counts coming from mitochondrial genes, since these may be damaged cells.
Notice the reduced number of columns in the dataset below.

```{r}
(sce <- sce[, sce$subsets_MT_percent < 5])
```

Next, we calculate size factors and normalized and log-transformed expression values, using the `r Biocpkg("scran")` and `r Biocpkg("scater")` packages.
Note that it is typically recommended to pre-cluster the cells before computing the size factors, as follows:

```{r}
# set.seed(1000)
# clusters <- scran::quickCluster(sce, BSPARAM = IrlbaParam())
# sce <- scran::computeSumFactors(sce, cluster = clusters, min.mean = 0.1)
```

However, for time reasons, we will skip the pre-clustering step in this workshop.

```{r, message=FALSE}
library("scran")
sce <- scran::computeSumFactors(sce, min.mean = 0.1)
summary(sizeFactors(sce))
sce <- scater::logNormCounts(sce)
```

In order to extract the most informative genes, we first model the mean-variance trend and decompose the variance into biological and technical components.

```{r}
dec <- scran::modelGeneVar(sce)
top.dec <- dec[order(dec$bio, decreasing = TRUE), ] 
head(top.dec)
```

Next, we apply Principal Components Analysis (PCA) and t-distributed Stochastic Neighbor Embedding (t-SNE) to generate low-dimensional representations of the cells in our data set.
These low-dimensional representations are added to the `reducedDim` slot of the `SingleCellExperiment` object.

```{r, message=FALSE}
library("BiocSingular")
set.seed(1000)
sce <- scran::denoisePCA(sce, technical = dec)
ncol(reducedDim(sce, "PCA"))
set.seed(1000)
sce <- scater::runTSNE(sce, dimred = "PCA", perplexity = 30)
sce <- scater::runUMAP(sce, dimred = "PCA")
sce
```

Finally, we cluster the cells using a graph-based algorithm, and find 'marker genes' for each cluster as the genes that are significantly upregulated in the cluster compared to each of the other inferred clusters.
The adjusted p-values from this test, for each cluster, are added to the `rowData` slot of the object.

```{r}
snn.gr <- scran::buildSNNGraph(sce, use.dimred = "PCA")
clusters <- igraph::cluster_walktrap(snn.gr)
sce$Cluster <- factor(clusters$membership)
table(sce$Cluster)

markers <- scran::findMarkers(sce, groups = sce$Cluster,
                              test.type = "t",
                              direction = "up", pval.type = "all")
for (i in names(markers)) {
    rowData(sce)[, paste0("FDR_cluster", i)] <- 
        markers[[i]]$FDR[match(rownames(sce), 
                               rownames(markers[[i]]))]
}
sce
```

This concludes the preparation of the data.
We have now a `SingleCellExperiment` object that contains different types of abundance values, representations in reduced dimensions, as well as a range of row (feature) and column (cell) metadata.

We can launch an `r Biocpkg("iSEE")` instance for exploring this data set using the `iSEE()` function:

```{r, message=FALSE}
library("iSEE")

if(interactive())
   iSEE(sce)
```

```{r}
saveRDS(sce, 
        file = "datasets/sce_pbmc3k_new.RDS")

sce_pbmc3k <- readRDS("datasets/sce_pbmc3k.RDS")
```


# Interoperability

## What about the same dataset, but for Seurat?

```{r eval=FALSE}
library("Seurat")
# seurat_object <- as.Seurat(sce)

seurat_object <- Seurat::CreateSeuratObject(
  counts = as.matrix(counts(sce)), 
  meta.data = as.data.frame(colData(sce))
)

seurat_object <- Seurat::SetAssayData(
  object = seurat_object, 
  slot = "data", 
  new.data = as.matrix(logcounts(sce))
)

# Set feature metadata, AKA rowData. Super intuitive, right?
seurat_object[["RNA"]][[]] <- as.data.frame(rowData(sce))

seurat_object <- FindVariableFeatures(seurat_object, selection.method = "vst", nfeatures = 2000)

all.genes <- rownames(seurat_object)
seurat_object <- ScaleData(seurat_object, features = all.genes)

seurat_object <- RunPCA(seurat_object, features = VariableFeatures(seurat_object))
seurat_object <- RunUMAP(seurat_object, dims = 1:10)

saveRDS(seurat_object, 
        file = "datasets/seurat_pbmc3k.RDS")

sce_from_seurat <- Seurat::as.SingleCellExperiment(
  readRDS("datasets/seurat_pbmc3k.RDS")
)
sce_from_seurat

if(interactive())
  iSEE(sce_from_seurat)
```

## And where is my AnnData object?

```{r eval=FALSE}
library("zellkonverter")

sce$Tissue_status <- NULL

zellkonverter::writeH5AD(sce,
                         file = "datasets/anndata_pbmc3k.h5ad",
                         compression = "gzip")
  
sce_from_anndata <- zellkonverter::readH5AD(file = "datasets/anndata_pbmc3k.h5ad")
sce_from_anndata

if(interactive())
  iSEE(sce_from_anndata)
```

# Session info {-}

```{r}
sessionInfo()
```

